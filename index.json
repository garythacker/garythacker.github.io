[{"categories":null,"content":"Concurrent programming in Go can be a bit like juggling—keeping many tasks in the air at once. The context package in Go acts as your trusty assistant, helping you manage this juggling act with finesse. In this blog post, we’re going to unravel the secrets of the context package. It’s your toolkit for handling tricky situations in concurrent programs, such as canceling tasks, setting deadlines, and smoothly passing information between different parts of your code. Think of it as your guide to becoming a concurrency maestro in Go. We’ll start with the basics, explore how to use the context package in real-life scenarios, and wrap up with tips to keep your concurrent programs running smoothly. ","date":"2023-11-24","objectID":"/golang-context-complete-guide/:0:0","tags":["golang","concurrency"],"title":"Golang Context Guide in Concurrent Programs","uri":"/golang-context-complete-guide/"},{"categories":null,"content":"Context Package Let’s have a look at the code for the context package. // A Context carries a deadline, a cancellation signal, and other values across // API boundaries. // // Context's methods may be called by multiple goroutines simultaneously. type Context interface { // Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set. Successive calls to Deadline return the same results. Deadline() (deadline time.Time, ok bool) // Done returns a channel that's closed when work done on behalf of this // context should be canceled. Done may return nil if this context can // never be canceled. Successive calls to Done return the same value. // The close of the Done channel may happen asynchronously, // after the cancel function returns. Done() \u003c-chan struct{} // If Done is not yet closed, Err returns nil. // If Done is closed, Err returns a non-nil error explaining why: // Canceled if the context was canceled // or DeadlineExceeded if the context's deadline passed. // After Err returns a non-nil error, successive calls to Err return the same error. Err() error // Value returns the value associated with this context for key, or nil // if no value is associated with key. Successive calls to Value with // the same key returns the same result. Value(key any) any } It is quite simple and we will be mostly using the Done() \u003c- chan struct{} function. Let’s have a look at the functions provided by the context package that we will use. // WithCancel returns a copy of parent with a new Done channel. The returned // context's Done channel is closed when the returned cancel function is called // or when the parent context's Done channel is closed, whichever happens first. // // Canceling this context releases resources associated with it, so code should // call cancel as soon as the operations running in this Context complete. func WithCancel(parent Context) (ctx Context, cancel CancelFunc) // WithDeadline returns a copy of the parent context with the deadline adjusted // to be no later than d. If the parent's deadline is already earlier than d, // WithDeadline(parent, d) is semantically equivalent to parent. The returned // [Context.Done] channel is closed when the deadline expires, when the returned // cancel function is called, or when the parent context's Done channel is // closed, whichever happens first. // // Canceling this context releases resources associated with it, so code should // call cancel as soon as the operations running in this [Context] complete. func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) // WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)). // // Canceling this context releases resources associated with it, so code should // call cancel as soon as the operations running in this [Context] complete: // // func slowOperationWithTimeout(ctx context.Context) (Result, error) { // ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond) // defer cancel() // releases resources if slowOperation completes before timeout elapses // return slowOperation(ctx) // } func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) In most of the times these 3 functions are used and I will be giving examples on how to use them effectively. ","date":"2023-11-24","objectID":"/golang-context-complete-guide/:1:0","tags":["golang","concurrency"],"title":"Golang Context Guide in Concurrent Programs","uri":"/golang-context-complete-guide/"},{"categories":null,"content":"Demo Showcase of the Concurrency We will write some pseudo-code first to understand the flow, then implement it in golang. - channel is declared - some goroutine(s) is writing into the channel - some goroutines(s) are listening from channel in parallel and process the messages - wait for the listeners to finish the processing and exit the program For our example, we will be having 2 goroutines listening to a channel and the main goroutine writing into the channel. A simple program is with 2 second timeout can be written as package main import ( \"context\" \"log\" \"sync\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second) defer cancel() dataChannel := make(chan int) var wg sync.WaitGroup wg.Add(2) for j := 0; j \u003c 2; j++ { go func(i int) { worker(ctx, dataChannel, i) wg.Done() }(j) } i := 0 for i \u003c 5 { dataChannel \u003c- i i++ } wg.Wait() } func worker(ctx context.Context, ch chan int, number int) { for { select { case \u003c-ctx.Done(): log.Printf(\"context canceled, exiting for worker number %d\\n\", number) return case i, ok := \u003c-ch: // It means channel is closed if !ok { log.Printf(\"channel is closed, exiting worker %d\\n\", number) return } log.Printf(\"worker: %d: read %v from channel\\n\", number, i) } } } ","date":"2023-11-24","objectID":"/golang-context-complete-guide/:2:0","tags":["golang","concurrency"],"title":"Golang Context Guide in Concurrent Programs","uri":"/golang-context-complete-guide/"},{"categories":null,"content":"Explanation of the Demo Let’s split the code and explain what each part is doing. // ... ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second) defer cancel() dataChannel := make(chan int) // ... We are initializing the context variable with 2 second timeout. So if our program is taking more than 2 second, we want the program to exit it and inform the sub-goroutines about it. Calling defer cancel() releases resources if the program completes before 2 second. In the last line, we are creating the channel which will be the main communication system for our program. // ... var wg sync.WaitGroup wg.Add(2) for j := 0; j \u003c 2; j++ { go func(i int) { worker(ctx, dataChannel, i) wg.Done() }(j) } // ... This line of code initializes a waitgroup and runs the goroutines in the background. sync.WaitGroup is used to make sure that we are waiting for goroutines to finish the processing so we can exit the code. // ... i := 0 for i \u003c 5 { dataChannel \u003c- i i++ } wg.Wait() // .. In this lines of code we are writing simple numbers to the channel, so the goroutines has something to read. In the last line, we are waiting on the sync.WaitGroup which means we are waiting goroutines to finish. 4. func worker(ctx context.Context, ch chan int, number int) { for { select { case \u003c-ctx.Done(): log.Printf(\"context canceled, exiting for worker number %d\\n\", number) return case i, ok := \u003c-ch: // It means channel is closed if !ok { log.Printf(\"channel is closed, exiting worker %d\\n\", number) return } log.Printf(\"worker: %d: read %v from channel\\n\", number, i) } } } worker function takes the context parameter and the data channel. ctx is passed to check if the context is canceled or not. if the context is canceled, the goroutine will exit which is the wanted behaviour of the code. channel is passed to read the data from the main goroutine if the channel is closed, it means that there are no data to read from so we can exit. When you run the code, here is what is going to happen: The goroutines will start to listen the channel. The main goroutine will write to the channel. Goroutines will receive some values from the channel and print some stuff. When the 2 second passes, the context will be canceled which means that the goroutines will also exit and the waitgroup value will be 0. the program will exit. Let’s run the code and see the output. go run main.go output 2023/11/24 21:15:27 worker: 1: read 0 from channel 2023/11/24 21:15:27 worker: 1: read 2 from channel 2023/11/24 21:15:27 worker: 0: read 1 from channel 2023/11/24 21:15:27 worker: 0: read 4 from channel 2023/11/24 21:15:27 worker: 1: read 3 from channel 2023/11/24 21:15:29 context canceled, exiting for worker number 0 2023/11/24 21:15:29 context canceled, exiting for worker number 1 As we can see from the output, the goroutines read some values from the channel, then waited for the context to cancel. When the context is canceled, it is the end time for the goroutines, so they exit, which also results in the main program exit. From the times of the logs, we can see that the program took nearly 2 seconds to finish. ","date":"2023-11-24","objectID":"/golang-context-complete-guide/:2:1","tags":["golang","concurrency"],"title":"Golang Context Guide in Concurrent Programs","uri":"/golang-context-complete-guide/"},{"categories":null,"content":"Channel Close Case Let’s say before the timeout, the channel is closed by the main goroutine which can mean we wrote all of the data we want to process into the channel, it is time to go. we processed all of the messages from the channel before the timeout, which is exactly what is wanted in real world case, the program should finish before the timeout value. The goroutines should process all of the messages and exit when the channel is closed. So, let’s modify our code to close the channel when there is no data to write to channel. package main import ( \"context\" \"log\" \"sync\" \"time\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second) defer cancel() dataChannel := make(chan int) var wg sync.WaitGroup wg.Add(2) for j := 0; j \u003c 2; j++ { go func(i int) { worker(ctx, dataChannel, i) wg.Done() }(j) } i := 0 for i \u003c 5 { dataChannel \u003c- i i++ } close(dataChannel) wg.Wait() } func worker(ctx context.Context, ch chan int, number int) { for { select { case \u003c-ctx.Done(): log.Printf(\"context canceled, exiting for worker number %d\\n\", number) return case i, ok := \u003c-ch: // It means channel is closed if !ok { log.Printf(\"channel is closed, exiting worker %d\\n\", number) return } log.Printf(\"worker: %d: read %v from channel\\n\", number, i) } } } At line 31, we are closing the channel. Now let’s run the code again and see the output \u003e go run main.go Output 2023/11/24 21:21:07 worker: 1: read 0 from channel 2023/11/24 21:21:07 worker: 1: read 2 from channel 2023/11/24 21:21:07 worker: 1: read 3 from channel 2023/11/24 21:21:07 worker: 1: read 4 from channel 2023/11/24 21:21:07 channel is closed, exiting worker 1 2023/11/24 21:21:07 worker: 0: read 1 from channel 2023/11/24 21:21:07 channel is closed, exiting worker 0 What we see from the output is that whenever the channel is closed, the worker exits and the program finishes. You can see from the log times that program exited really quickly before the 2 second timeout of the context, there was no chance for the context to cancel. Our program is safe by checking context cancellation channel close check There are 2 conditions we want our program to finish either process all of the data and exit or exit after the timeout. In golang, the best practice for goroutines is to know when they should exit and passing context.Context and checking if it is cancelled is one of the best way to handle the goroutines. In this example we used the context.Timeout but there are other options as we defined in the Context Package Section. You can use context.WithCancel and manually cancel the context whenever you want to. context.WithDeadline and set a deadline for your program to finish. I hope this blog helped you understand how to use context to propagate the program exit to the sub-goroutines. Any feedback is appreciated. ","date":"2023-11-24","objectID":"/golang-context-complete-guide/:2:2","tags":["golang","concurrency"],"title":"Golang Context Guide in Concurrent Programs","uri":"/golang-context-complete-guide/"},{"categories":null,"content":"REFERENCES pkg.go.dev/context ","date":"2023-11-24","objectID":"/golang-context-complete-guide/:3:0","tags":["golang","concurrency"],"title":"Golang Context Guide in Concurrent Programs","uri":"/golang-context-complete-guide/"},{"categories":null,"content":"Building a REST API that plays nice with MongoDB is a common challenge in web development. But how do you make sure it all works seamlessly? That’s where integration testing comes in. In this blog post, we’re going to break down the process of writing integration tests for your REST API, specifically when MongoDB is in the mix. You can get all of the code samples for this blog from this repository. ","date":"2023-11-10","objectID":"/golang-mongo-db-rest-api-integration-tests/:0:0","tags":["golang","mongodb","rest","tests"],"title":"Integration Testing for MongoDB-Backed REST APIs with Golang","uri":"/golang-mongo-db-rest-api-integration-tests/"},{"categories":null,"content":"Simple Design of the API simple design of api As you can see, only component of our API is MongoDB, which is kind of not realistic for real life examples but you will get the idea on how to apply for it for multiple components for integration tests. ","date":"2023-11-10","objectID":"/golang-mongo-db-rest-api-integration-tests/:1:0","tags":["golang","mongodb","rest","tests"],"title":"Integration Testing for MongoDB-Backed REST APIs with Golang","uri":"/golang-mongo-db-rest-api-integration-tests/"},{"categories":null,"content":"Database Models For the API Each author can have many books Each book can have many comments. Please do not try to validate the design of the models. It is just designed in a way where I can write the code fast and have the tests ready in short period of time. ","date":"2023-11-10","objectID":"/golang-mongo-db-rest-api-integration-tests/:2:0","tags":["golang","mongodb","rest","tests"],"title":"Integration Testing for MongoDB-Backed REST APIs with Golang","uri":"/golang-mongo-db-rest-api-integration-tests/"},{"categories":null,"content":"API Our api has 3 different endpoints. GET /api/books: returns all of the books with their corresponding comments. GET /api/author/{id}/books: returns the books of the author with given id. POST /api/book: creates a new book. You can check the example request and responses from the project readme. ","date":"2023-11-10","objectID":"/golang-mongo-db-rest-api-integration-tests/:3:0","tags":["golang","mongodb","rest","tests"],"title":"Integration Testing for MongoDB-Backed REST APIs with Golang","uri":"/golang-mongo-db-rest-api-integration-tests/"},{"categories":null,"content":"How to Design Integration Tests Let’s check our PostsController class which is basically handling all of the requests. type PostsController struct { repo repository.Repository } func New(repo repository.Repository) *PostsController { return \u0026PostsController{repo: repo} } As we can see, the only dependency for the PostsController is the Repository. Let’s check the Repository interface. type Repository interface { GetBooksWithComments(ctx context.Context, filter PostFilter) ([]models.BookWithComments, error) CreateBook(ctx context.Context, book models.Book) (models.Book, error) GetAuthorById(ctx context.Context, id string) (*models.Author, error) } func New(db *mongo.Database) Repository { return \u0026mongoRepository{db: db} } type mongoRepository struct { db *mongo.Database } mongoRepository implements the Repository interface and, the only dependency for it is the mongo.Database. In short terms, to be able to test our controller end2end, we need a MongoDB connection, but the real question is how to get a real MongoDB connection. ","date":"2023-11-10","objectID":"/golang-mongo-db-rest-api-integration-tests/:3:1","tags":["golang","mongodb","rest","tests"],"title":"Integration Testing for MongoDB-Backed REST APIs with Golang","uri":"/golang-mongo-db-rest-api-integration-tests/"},{"categories":null,"content":"Test Containers The answer is to use the Test-Containers. What is test-containers? Testcontainers is an open source framework for providing throwaway, lightweight instances of databases, message brokers, web browsers, or just about anything that can run in a Docker container1. So, here is our strategy for testing. Run a MongoDB container with Test-Containers before doing the test. Create the database connection with the MongoDB container. Pass this connection to our API Controllers Do the API Testing Remove the MongoDB container after doing the testing. ","date":"2023-11-10","objectID":"/golang-mongo-db-rest-api-integration-tests/:3:2","tags":["golang","mongodb","rest","tests"],"title":"Integration Testing for MongoDB-Backed REST APIs with Golang","uri":"/golang-mongo-db-rest-api-integration-tests/"},{"categories":null,"content":"How to Implement With Golang We can use the testing.Main. M is a type passed to a TestMain function to run the actual tests 2. Let’s implement the TestingMain var ( testDbInstance *mongo.Database ) func TestMain(m *testing.M) { log.Println(\"setup is running\") testDB := SetupTestDatabase() testDbInstance = testDB.DbInstance populateDB() exitVal := m.Run() log.Println(\"teardown is running\") _ = testDB.container.Terminate(context.Background()) os.Exit(exitVal) } populateDB() function inserts some data to the database so we can do our testing. Let’s check the SetupTestDatabase() which is basically creating the MongoDB container and creating the connection to that container. type TestDatabase struct { DbInstance *mongo.Database DbAddress string container testcontainers.Container } func SetupTestDatabase() *TestDatabase { ctx, _ := context.WithTimeout(context.Background(), time.Second*60) container, dbInstance, dbAddr, err := createMongoContainer(ctx) if err != nil { log.Fatal(\"failed to setup test\", err) } return \u0026TestDatabase{ container: container, DbInstance: dbInstance, DbAddress: dbAddr, } } func (tdb *TestDatabase) TearDown() { _ = tdb.container.Terminate(context.Background()) } func createMongoContainer(ctx context.Context) (testcontainers.Container, *mongo.Database, string, error) { var env = map[string]string{ \"MONGO_INITDB_ROOT_USERNAME\": \"root\", \"MONGO_INITDB_ROOT_PASSWORD\": \"pass\", \"MONGO_INITDB_DATABASE\": \"testdb\", } var port = \"27017/tcp\" req := testcontainers.GenericContainerRequest{ ContainerRequest: testcontainers.ContainerRequest{ Image: \"mongo\", ExposedPorts: []string{port}, Env: env, }, Started: true, } container, err := testcontainers.GenericContainer(ctx, req) if err != nil { return container, nil, \"\", fmt.Errorf(\"failed to start container: %v\", err) } p, err := container.MappedPort(ctx, \"27017\") if err != nil { return container, nil, \"\", fmt.Errorf(\"failed to get container external port: %v\", err) } log.Println(\"mongo container ready and running at port: \", p.Port()) uri := fmt.Sprintf(\"mongodb://root:pass@localhost:%s\", p.Port()) db, err := database.NewMongoDatabase(uri) if err != nil { return container, db, uri, fmt.Errorf(\"failed to establish database connection: %v\", err) } return container, db, uri, nil } Now that we have the mongo.Database, we can create the Repository and then we can create the PostsController. import ( \"github.com/labstack/echo/v4\" \"github.com/garythacker/mongoapi/internal/controllers\" \"github.com/garythacker/mongoapi/internal/repository\" \"github.com/garythacker/mongoapi/pkg/router\" ) func InitializeTestRouter() *echo.Echo { postgreRepo := repository.New(testDbInstance) userController := controllers.New(postgreRepo) return router.Initialize(userController) } Let’s also check the router.Initialize() to see which endpoints there are. func Initialize(controller *controllers.PostsController) *echo.Echo { e := echo.New() api := e.Group(\"/api\") api.GET(\"/books\", controller.GetBooksWithComments()) api.POST(\"/book\", controller.CreateBook()) api.GET(\"/author/:id/books\", controller.GetAuthorBooksWithComments()) return e } Now we have the router and we can test the endpoints. ","date":"2023-11-10","objectID":"/golang-mongo-db-rest-api-integration-tests/:3:3","tags":["golang","mongodb","rest","tests"],"title":"Integration Testing for MongoDB-Backed REST APIs with Golang","uri":"/golang-mongo-db-rest-api-integration-tests/"},{"categories":null,"content":"apitest package You can create the tests with net/http package but it will create a lot of boilerplate code. There is a package called apitest. It has a lot of easy features such as reading body from a file easily check the response status code checking body from a file and so on… One of the endpoints is to create books for given author. Let’s see the controller code for context on what it is doing. func (u PostsController) CreateBook() echo.HandlerFunc { return func(c echo.Context) error { req := new(CreateBookRequest) if err := c.Bind(\u0026req); err != nil { return c.JSON(http.StatusBadRequest, map[string]interface{}{ \"err\": err.Error(), }) } objId, err := primitive.ObjectIDFromHex(req.AuthorId) if err != nil { return c.JSON(http.StatusBadRequest, map[string]interface{}{ \"err\": err.Error(), }) } author, err := u.repo.GetAuthorById(c.Request().Context(), objId.Hex()) if err != nil { if errors.Is(err, mongo.ErrNoDocuments) { return c.JSON(http.StatusNotFound, map[string]interface{}{ \"err\": \"author does not exist\", }) } } createdBook, err := u.repo.CreateBook(c.Request().Context(), models.Book{ Title: req.BookName, Author: *author, Likes: 0, }) if err != nil { return c.JSON(http.StatusInternalServerError, map[string]interface{}{ \"err\": err.Error(), }) } return c.JSON(http.StatusCreated, map[string]interface{}{ \"book\": createdBook, }) } } it checks if the author exists if author exists, then create the book in the database. Here is an example request and response from the server. curl --location 'http://localhost:3030/api/book' \\ --header 'Content-Type: application/json' \\ --data '{ \"book_name\": \"The Idiot\", \"author_id\": \"654e619760034d917aa0ae64\" }' Response { \"book\": { \"title\": \"The Idiot\", \"author\": { \"id\": \"654e619760034d917aa0ae64\", \"name\": \"Marcus Aurelius\" }, \"likes\": 0 } } As we can see the book is created and returned from the response. To test this endpoint end2end way you need to pass the correct body, expected response and expected response status code. I already created the json files for you. request body: https://github.com/garythacker/golang-mongo-rest-api/blob/main/internal/controllers/integration_test/requests/create_book_success.json response body: https://github.com/garythacker/golang-mongo-rest-api/blob/main/internal/controllers/integration_test/responses/create_book_response.json Let’s write the test function package integrationtest import ( \"context\" \"fmt\" \"log\" \"net/http\" \"os\" \"testing\" \"github.com/labstack/echo/v4\" \"github.com/garythacker/mongoapi/internal/controllers\" \"github.com/garythacker/mongoapi/internal/repository\" \"github.com/garythacker/mongoapi/pkg/router\" \"github.com/steinfletcher/apitest\" \"github.com/steinfletcher/apitest-jsonpath\" \"go.mongodb.org/mongo-driver/mongo\" ) var ( testDbInstance *mongo.Database ) func TestMain(m *testing.M) { log.Println(\"setup is running\") testDB := SetupTestDatabase() testDbInstance = testDB.DbInstance populateDB() exitVal := m.Run() log.Println(\"teardown is running\") _ = testDB.container.Terminate(context.Background()) os.Exit(exitVal) } func InitializeTestRouter() *echo.Echo { postgreRepo := repository.New(testDbInstance) userController := controllers.New(postgreRepo) return router.Initialize(userController) } func TestCreatePostSuccess(t *testing.T) { apitest.New(). Handler(InitializeTestRouter()). Post(\"/api/book\"). Header(\"content-type\", \"application/json\"). BodyFromFile(\"requests/create_book_success.json\"). Expect(t). Status(http.StatusCreated). BodyFromFile(\"responses/create_book_response.json\"). End() } Let’s analyze the commands step by step. apitest.New(): New creates a new api test. The name is optional and will appear in test reports Handler(InitializeTestRouter()): initializes the endpoints and their corresponding handlers. Post(\"/api/book\").: sends a POST request to /api/book endpoint. Header(\"content-type\", \"application/json\").: sets the content-type header. BodyFromFile(\"requests/create_book_success.json\"): reads the body from given file and sets the ","date":"2023-11-10","objectID":"/golang-mongo-db-rest-api-integration-tests/:3:4","tags":["golang","mongodb","rest","tests"],"title":"Integration Testing for MongoDB-Backed REST APIs with Golang","uri":"/golang-mongo-db-rest-api-integration-tests/"},{"categories":null,"content":"SQS (Simple Queue Service) Query Examples This page should help you to understand how to use AWS SQS with golang using the official aws-sdk-go-v2/service/sqs. We will start with some basics like how to create the client to rather more complex operations such as Sending Message etc. ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:0:0","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"Setup Connecting Go application to SQS Client is quite easy. You just need to load your config and create the client. You need to get the below packages go get -u github.com/aws/aws-sdk-go-v2/config go get -u github.com/aws/aws-sdk-go-v2/service/sqs package main import ( \"context\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } sqsClient := sqs.NewFromConfig(cfg) } ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:1:0","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"Create Queue AS we know, the messages are stored in the queues, so without a queue we will not be able to operate any function. Creating queues from AWS CLI is quite easy, it is also easy with AWS SDK. Let’s create a queue with the name test_queue. package main import ( \"context\" \"log\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } sqsClient := sqs.NewFromConfig(cfg) queue, err := sqsClient.CreateQueue(context.TODO(), \u0026sqs.CreateQueueInput{ QueueName: aws.String(\"test_queue\"), Attributes: nil, Tags: nil, }) if err != nil { panic(err) } log.Printf(\"the queue url is %v\", *queue.QueueUrl) } Now we have a queue with the name test_queue. ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:2:0","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"Fetch Queue URL Some operations such as sending message to a queue or deleting the queue needs the queue url as input. Even though we know the name of the queue, we still need to fetch the URL of it. It is quite easy. package main import ( \"context\" \"log\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } sqsClient := sqs.NewFromConfig(cfg) queue, err := sqsClient.GetQueueUrl(context.TODO(), \u0026sqs.GetQueueUrlInput{ QueueName: aws.String(\"test_queue\"), QueueOwnerAWSAccountId: nil, }) if err != nil { panic(err) } log.Printf(\"the queue url is %v\", *queue.QueueUrl) } ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:3:0","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"Delete Queue Deleting the queue is also quite easy. You just need to call the DeleteQueue function. You will be using this a lot if you create temporary queues and need to delete them after a while. package main import ( \"context\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } sqsClient := sqs.NewFromConfig(cfg) queue, err := sqsClient.GetQueueUrl(context.TODO(), \u0026sqs.GetQueueUrlInput{ QueueName: aws.String(\"test_queue\"), QueueOwnerAWSAccountId: nil, }) if err != nil { panic(err) } _, err = sqsClient.DeleteQueue(context.TODO(), \u0026sqs.DeleteQueueInput{QueueUrl: queue.QueueUrl}) if err != nil { panic(err) } } ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:4:0","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"List Queues Sometimes we need to list the queues to see which queues there are in the AWS. You can even set a prefix to get the queues with wanted prefix. Let’s fetch the queues with prefix test. package main import ( \"context\" \"log\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } sqsClient := sqs.NewFromConfig(cfg) queues, err := sqsClient.ListQueues(context.TODO(), \u0026sqs.ListQueuesInput{ MaxResults: nil, NextToken: nil, QueueNamePrefix: aws.String(\"test\"), }) if err != nil { panic(err) } for _, queueUrl := range queues.QueueUrls { log.Println(queueUrl) } } ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:5:0","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"Send Message The most important part of the queues is mostly is receiving \u0026 sending messages part. The whole point of the queue is to become the middle man which has the responsibility of taking and delivering the messages. Sending a message in SQS quite easy. package main import ( \"context\" \"encoding/json\" \"log\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) type YourStruct struct { Artist string Song string } func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } sqsClient := sqs.NewFromConfig(cfg) data := YourStruct{ Artist: \"Queen\", Song: \"The Show Must Go On\", } bytes, _ := json.Marshal(\u0026data) queue, _ := sqsClient.GetQueueUrl(context.TODO(), \u0026sqs.GetQueueUrlInput{ QueueName: aws.String(\"test_queue\"), }) res, err := sqsClient.SendMessage(context.TODO(), \u0026sqs.SendMessageInput{ MessageBody: aws.String(string(bytes)), QueueUrl: queue.QueueUrl, DelaySeconds: 0, MessageAttributes: nil, MessageDeduplicationId: nil, MessageGroupId: nil, MessageSystemAttributes: nil, }) if err != nil { panic(err) } log.Printf(\"the message with id %v is sent\", *res.MessageId) } ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:6:0","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"Receive Message The other most important part of the queues are receiving the message, because as we know the messages are only sent for someone to read it. I think that could be a good quote so let’s make a one. Gary Thacker Messages are only sent for someone to read it. Handling messages in SQS can be quite complex. If you want to learn how to receive message and handle them in parallel, check out my other post Golang Sqs Consumer Worker Pool. package main import ( \"context\" \"log\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } sqsClient := sqs.NewFromConfig(cfg) queue, _ := sqsClient.GetQueueUrl(context.TODO(), \u0026sqs.GetQueueUrlInput{ QueueName: aws.String(\"test_queue\"), }) messages, err := sqsClient.ReceiveMessage(context.TODO(), \u0026sqs.ReceiveMessageInput{ QueueUrl: queue.QueueUrl, AttributeNames: nil, MaxNumberOfMessages: 10, // max is 10 MessageAttributeNames: nil, ReceiveRequestAttemptId: nil, VisibilityTimeout: 0, WaitTimeSeconds: 0, }) if err != nil { panic(err) } for _, message := range messages.Messages { log.Printf(\"the message body is %v\", *message.Body) } } Output will be something like this 2023/10/18 22:22:57 the message body is {\"Artist\":\"Queen\",\"Song\":\"The Show Must Go On\"} ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:7:0","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"How to Decode the Message Into Your Struct You just need to decode it via json.Unmarshal to your struct. for _, message := range messages.Messages { var data YourStruct _ = json.Unmarshal([]byte(*message.Body), \u0026data) log.Printf(\"the received data is %+v\", data) } ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:7:1","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"Delete Message In general after handling the message, you will want to delete the message so it will not be received and handled again. Of course this can change according to your needs. Deleting the message is quite easy. package main import ( \"context\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) type YourStruct struct { University string Major string Level string } func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } sqsClient := sqs.NewFromConfig(cfg) queue, _ := sqsClient.GetQueueUrl(context.TODO(), \u0026sqs.GetQueueUrlInput{ QueueName: aws.String(\"test_queue\"), }) // It can be read from message variable after receiving from SQS messageHandle := \"YOUR_MESSAGE_HANDLE\" _, err = sqsClient.DeleteMessage(context.TODO(), \u0026sqs.DeleteMessageInput{ QueueUrl: queue.QueueUrl, ReceiptHandle: \u0026messageHandle, }) if err != nil { panic(err) } } ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:8:0","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"Purge Queue If you want to delete all of the messages in the queue, you need to use the PurgeQueue method. package main import ( \"context\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/config\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" ) func main() { cfg, err := config.LoadDefaultConfig(context.TODO()) if err != nil { panic(err) } sqsClient := sqs.NewFromConfig(cfg) queue, _ := sqsClient.GetQueueUrl(context.TODO(), \u0026sqs.GetQueueUrlInput{ QueueName: aws.String(\"test_queue\"), }) _, err = sqsClient.PurgeQueue(context.TODO(), \u0026sqs.PurgeQueueInput{ QueueUrl: queue.QueueUrl, }) if err != nil { panic(err) } } ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:9:0","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"Motivation This post is too basic with SQS but it might help a beginner programmer who is trying to do some stuff with SQS. While I was doing some development with DynamoDB, I got help from this blog. It really helped me to get the development going. I wanted to do it the same with SQS. The reason I do it with SQS is I work with it often, so I know some stuff about it. Hope, it will help you. If it helps or not, you can reach out to me. Let’s end the topic with a calming music. Enjoy 🎵 💻 ","date":"2023-10-18","objectID":"/aws-sqs-golang-function-examples/:10:0","tags":["golang","sqs","aws"],"title":"AWS SQS SDK \u0026 Golang Complete Cheat Sheet","uri":"/aws-sqs-golang-function-examples/"},{"categories":null,"content":"Hello Guys, In this post we will analyze some of my bullet games on Lichess. I love playing chess, and I try to play bullet games almost every day, at least 3-4 games. I thought, it is time to analyze some of my games with Python. To be able to do it, we need to use the Lichess API to export my games. There is already a client package implemented in Python3 called Berserk, so I will be using it. We will use pandas to manipulate the data and matplotlib to plot some charts (hopefully we will get some meaning based on them). I have more than 5000 games as of the data 16th Oct 2023. We will be analyzing last 1000 games. Let’s begin. I got help from ChatGPT while creating this notebook. Lichess Server Crash Image ","date":"2023-10-16","objectID":"/analysis-of-chess-games/:0:0","tags":["chess","python","data"],"title":"Analysis Of My Lichess Bullet Games","uri":"/analysis-of-chess-games/"},{"categories":null,"content":"Fetch the Games import berserk import pandas as pd import numpy as np import matplotlib.pyplot as plt with open('./lichess.token') as f: token = f.read() session = berserk.TokenSession(token) client = berserk.Client(session) client.games.export_by_player('IsaacNewton29', opening=True, perf_type=\"bullet\", max=1000) \u003cgenerator object Games.export_by_player at 0x1455dbcf0\u003e games = list(_) df = pd.DataFrame(games) df = df.drop(columns=['id', 'rated', 'variant', 'speed', 'perf', 'clock', 'lastMoveAt']) df.head(2) createdAt status players winner opening moves 0 2023-10-16 17:34:35.325000+00:00 mate {'white': {'user': {'name': 'Chessington008', ... white {'eco': 'B01', 'name': 'Scandinavian Defense: ... e4 d5 exd5 Qxd5 Nc3 Qd8 Bc4 Nc6 Nf3 Nf6 d4 e6 ... 1 2023-10-16 14:06:40.830000+00:00 outoftime {'white': {'user': {'name': 'IsaacNewton29', '... black {'eco': 'C00', 'name': 'French Defense', 'ply'... e4 e6 Bc4 d5 exd5 exd5 Be2 c6 Nf3 Nf6 d4 Bd6 N... df.createdAt.min().date(), df.createdAt.max().date() (datetime.date(2022, 12, 15), datetime.date(2023, 10, 16)) It seems like I played the last 1000 games between the dates 12th December 2022 and 16th October 2023. Let’s extract the white and black players for each game. It will be useful df[\"white\"] = df[\"players\"].apply(lambda x: x[\"white\"][\"user\"][\"name\"]) df[\"black\"] = df[\"players\"].apply(lambda x: x[\"black\"][\"user\"][\"name\"]) df[df[\"white\"] == \"IsaacNewton29\"].shape (490, 8) df[df[\"black\"] == \"IsaacNewton29\"].shape (510, 8) df[((df[\"white\"] == \"IsaacNewton29\") \u0026 (df[\"winner\"] == \"white\")) | ((df[\"black\"] == \"IsaacNewton29\") \u0026 (df[\"winner\"] == \"black\"))].shape (495, 8) df[(df[\"black\"] == \"IsaacNewton29\") \u0026 (df[\"winner\"] == \"black\")].shape (224, 8) # Count the occurrences of each category category_counts = df['winner'].value_counts() # Plot a bar chart with counts displayed on top of each bar plt.figure(figsize=(8, 6)) bars = plt.bar(category_counts.index, category_counts.values, color='skyblue') # Add counts as labels on top of the bars for bar in bars: yval = bar.get_height() plt.text(bar.get_x() + bar.get_width()/2, yval, int(yval), ha='center', va='bottom') plt.xlabel('Player') plt.ylabel('Count') plt.title('Winner Counts Based on Color') plt.xticks(rotation=0) # Rotate x-axis labels if necessary plt.show() Let’s create a new column to check if I won that game. To get the value If the winner is white check if I play white If the winner is black check if I play black df[\"did_i_win\"] = ((df[\"white\"] == \"IsaacNewton29\") \u0026 (df[\"winner\"] == \"white\")) | ((df[\"black\"] == \"IsaacNewton29\") \u0026 (df[\"winner\"] == \"black\")) df[\"did_i_win\"].value_counts() did_i_win False 505 True 495 Name: count, dtype: int64 Let’s see on the chart to understand it better. # Count the occurrences of each category category_counts = df['did_i_win'].value_counts() # Plot a bar chart with counts displayed on top of each bar plt.figure(figsize=(8, 6)) bars = plt.bar(category_counts.index.values, category_counts.values, color='skyblue') # Add counts as labels on top of the bars for bar in bars: yval = bar.get_height() plt.text(bar.get_x() + bar.get_width()/2, yval, int(yval), ha='center', va='bottom') plt.xlabel('Is the Game a Win') plt.ylabel('Count') plt.title('Did I Win the Game') plt.xticks(range(len(category_counts.index)), category_counts.index) # Set x-tick labels plt.show() It seems like I lost 505 games whereas I won the 495 games, it is almost 50/50. No improvement at all 😄 It will be continued… ","date":"2023-10-16","objectID":"/analysis-of-chess-games/:1:0","tags":["chess","python","data"],"title":"Analysis Of My Lichess Bullet Games","uri":"/analysis-of-chess-games/"},{"categories":null,"content":"Introduction In the ever-evolving landscape of web development, GraphQL has emerged as a powerful alternative to traditional RESTful APIs. Its flexibility and efficiency have led many developers to consider migrating their REST endpoints to GraphQL. In this blog post, we will explore the process of converting a RESTful endpoint to GraphQL, unlocking the benefits of a more customizable and efficient data-fetching experience. Join us on this journey as we delve into the world of GraphQL and transform a RESTful API into a GraphQL powerhouse. ","date":"2023-09-07","objectID":"/golang-setup-graphql-server/:1:0","tags":["golang","network","rest","graphql"],"title":"Setting up a GraphQL Server in Golang","uri":"/golang-setup-graphql-server/"},{"categories":null,"content":"Rest API Implementation Let’s say that we have a server with a REST Endpoint structured as below. curl http://localhost:8080/artists and it returns [ { \"name\": \"The Weeknd\", \"age\": 30, \"tracks\": [ { \"name\": \"Creepin\", \"duration\": 222 } ] }, { \"name\": \"Tame Impala\", \"age\": 30, \"tracks\": [ { \"name\": \"Let It Happen\", \"duration\": 467 } ] } ] This endpoint simply can be handled by this below code. package main import ( \"encoding/json\" \"log\" \"net/http\" ) type Track struct { Name string `json:\"name\"` Duration int `json:\"duration\"` // in seconds } type Artist struct { Name string `json:\"name\"` Age int `json:\"age\"` Tracks []Track `json:\"tracks\"` } var data = []Artist{ { Name: \"The Weeknd\", Age: 30, Tracks: []Track{ {Name: \"Creepin\", Duration: 222}, }, }, { Name: \"Tame Impala\", Age: 35, Tracks: []Track{ {Name: \"Let It Happen\", Duration: 467}, }, }, } func main() { mux := http.NewServeMux() mux.HandleFunc(\"/artists\", func(w http.ResponseWriter, r *http.Request) { if err := json.NewEncoder(w).Encode(\u0026data); err != nil { return } }) log.Fatal(http.ListenAndServe(\":8080\", mux)) } ","date":"2023-09-07","objectID":"/golang-setup-graphql-server/:2:0","tags":["golang","network","rest","graphql"],"title":"Setting up a GraphQL Server in Golang","uri":"/golang-setup-graphql-server/"},{"categories":null,"content":"Structure Change But you only want some of the fields maybe like [ { \"name\": \"The Weeknd\", \"tracks\": [ { \"name\": \"Creepin\", } ] }, { \"name\": \"Tame Impala\", \"tracks\": [ { \"name\": \"Let It Happen\", } ] } ] You want to make it as a GraphQL query maybe something like query { getArtists { name tracks { name } } } Question is how to change this really simple API to a graphQL endpoint. ","date":"2023-09-07","objectID":"/golang-setup-graphql-server/:2:1","tags":["golang","network","rest","graphql"],"title":"Setting up a GraphQL Server in Golang","uri":"/golang-setup-graphql-server/"},{"categories":null,"content":"GraphQL Implementation For this we will use the package of https://github.com/99designs/gqlgen, you can have a look. To start the project, we will follow the quick quide. First create the project mkdir example cd example go mod init example Add 99designs/gqlgen to your project’s tools.go printf '// +build tools\\npackage tools\\nimport (_ \"github.com/99designs/gqlgen\"\\n _ \"github.com/99designs/gqlgen/graphql/introspection\")' | gofmt \u003e tools.go go mod tidy Initialise gqlgen config and generate models go run github.com/99designs/gqlgen init go mod tidy Start the graphql server go run server.go ","date":"2023-09-07","objectID":"/golang-setup-graphql-server/:3:0","tags":["golang","network","rest","graphql"],"title":"Setting up a GraphQL Server in Golang","uri":"/golang-setup-graphql-server/"},{"categories":null,"content":"Project structure Your folder structure should look like this ├── go.mod ├── go.sum ├── gqlgen.yml ├── graph │ ├── generated.go │ ├── model │ │ └── models_gen.go │ ├── resolver.go │ ├── schema.graphqls │ └── schema.resolvers.go ├── server.go └── tools.go ","date":"2023-09-07","objectID":"/golang-setup-graphql-server/:3:1","tags":["golang","network","rest","graphql"],"title":"Setting up a GraphQL Server in Golang","uri":"/golang-setup-graphql-server/"},{"categories":null,"content":"Generated Code and GraphiQL Playground Your server.go will look like this package main import ( \"log\" \"net/http\" \"os\" \"github.com/99designs/gqlgen/graphql/handler\" \"github.com/99designs/gqlgen/graphql/playground\" \"github.com/garythacker/graph/graph\" ) const defaultPort = \"8080\" func main() { port := os.Getenv(\"PORT\") if port == \"\" { port = defaultPort } srv := handler.NewDefaultServer(graph.NewExecutableSchema(graph.Config{Resolvers: \u0026graph.Resolver{}})) http.Handle(\"/\", playground.Handler(\"GraphQL playground\", \"/query\")) http.Handle(\"/query\", srv) log.Printf(\"connect to http://localhost:%s/ for GraphQL playground\", port) log.Fatal(http.ListenAndServe(\":\"+port, nil)) } When you run all of the commands above and run the project you should see something like this on your project We will be testing our query from the UI to easily see the results. ","date":"2023-09-07","objectID":"/golang-setup-graphql-server/:3:2","tags":["golang","network","rest","graphql"],"title":"Setting up a GraphQL Server in Golang","uri":"/golang-setup-graphql-server/"},{"categories":null,"content":"GraphQL File There is an autogenerated file schema.graphqls, we will be setting our Artist and Track models here. type Artist { name: String! age: Int! tracks: [Track!]! } type Track { name: String! duration: Int! } type Query { artists: [Artist!]! } Then run below command to auto-generate models resolver etc, we will just fill the logic. go run github.com/99designs/gqlgen generate Then the schema.resolvers.go file will be like this package graph // This file will be automatically regenerated based on the schema, any resolver implementations // will be copied through when generating and any unknown code will be moved to the end. // Code generated by github.com/99designs/gqlgen version v0.17.36 import ( \"context\" \"fmt\" \"github.com/garythacker/graph/graph/model\" ) // Artists is the resolver for the artists field. func (r *queryResolver) Artists(ctx context.Context) ([]*model.Artist, error) { panic(fmt.Errorf(\"not implemented: Artists - artists\")) } // Query returns QueryResolver implementation. func (r *Resolver) Query() QueryResolver { return \u0026queryResolver{r} } type queryResolver struct{ *Resolver } We will fill the Artists method, it will be a simple returning array of model.Artist which is in the model/models_gen.go (auto-generated file) // Code generated by github.com/99designs/gqlgen, DO NOT EDIT. package model type Artist struct { Name string `json:\"name\"` Age int `json:\"age\"` Tracks []*Track `json:\"tracks\"` } type Track struct { Name string `json:\"name\"` Duration int `json:\"duration\"` } ","date":"2023-09-07","objectID":"/golang-setup-graphql-server/:3:3","tags":["golang","network","rest","graphql"],"title":"Setting up a GraphQL Server in Golang","uri":"/golang-setup-graphql-server/"},{"categories":null,"content":"Implementation of the Resolver To implement the resolver we will return a hardcoded array of model.Artist struct. package graph // This file will be automatically regenerated based on the schema, any resolver implementations // will be copied through when generating and any unknown code will be moved to the end. // Code generated by github.com/99designs/gqlgen version v0.17.36 import ( \"context\" \"github.com/garythacker/graph/graph/model\" ) var data = []*model.Artist{ { Name: \"The Weeknd\", Age: 30, Tracks: []*model.Track{ {Name: \"Creepin\", Duration: 222}, }, }, { Name: \"Tame Impala\", Age: 60, Tracks: []*model.Track{ {Name: \"Let It Happen\", Duration: 467}, }, }, } // Artists is the resolver for the artists field. func (r *queryResolver) Artists(ctx context.Context) ([]*model.Artist, error) { return data, nil } // Query returns QueryResolver implementation. func (r *Resolver) Query() QueryResolver { return \u0026queryResolver{r} } type queryResolver struct{ *Resolver } Let’s run the server again and go to GraphiQL playground (http://localhost:8080/). go run server.go Then go to http://localhost:8080 and paste the query query { artists { name } } it will return { \"data\": { \"artists\": [ { \"name\": \"The Weeknd\" }, { \"name\": \"Tame Impala\" } ] } } You can play with the editor and convert your rest endpoints to GraphQL easily. ","date":"2023-09-07","objectID":"/golang-setup-graphql-server/:3:4","tags":["golang","network","rest","graphql"],"title":"Setting up a GraphQL Server in Golang","uri":"/golang-setup-graphql-server/"},{"categories":null,"content":"REFERENCES In summary, transitioning from REST to GraphQL offers numerous benefits for your API. It’s a journey worth taking, promising improved efficiency and flexibility. So, take that step, and may your GraphQL journey be both rewarding and transformative. Happy coding! https://github.com/99designs/gqlgen ","date":"2023-09-07","objectID":"/golang-setup-graphql-server/:4:0","tags":["golang","network","rest","graphql"],"title":"Setting up a GraphQL Server in Golang","uri":"/golang-setup-graphql-server/"},{"categories":null,"content":"MOTIVATION I work as a Software engineer over 15 years now as of August 2023. My work mostly relies on database systems such as MySQL, Redis, Mongo etc. So it would be great to learn the internals or system designs related to those database systems. Also it is stated in the book that, aynone working on backend side who processes data and the applications they developed uses internet should read this book, so I am quite a fit for the people who should read this book. I will make a blog post on each of the chapter I read, mostly I will read after my working hours so it will probably take months for me to really finish this book. ","date":"2023-08-27","objectID":"/notes-on-designing-data-intensive-applications/:0:0","tags":["backend","database","books"],"title":"My Notes on Designing Data Intensive Applications","uri":"/notes-on-designing-data-intensive-applications/"},{"categories":null,"content":"CHAPTER 1 - Reliable, Scalable and Maintainable Applications Most applications are data-intensive nowadays, the problems mostly related to amount of data etc. Most of the tools developed are highly advanced nowadays but none of them can meet all of the needs of different data processing and storing requirements. ","date":"2023-08-27","objectID":"/notes-on-designing-data-intensive-applications/:1:0","tags":["backend","database","books"],"title":"My Notes on Designing Data Intensive Applications","uri":"/notes-on-designing-data-intensive-applications/"},{"categories":null,"content":"Definitions Reliability The system should continue to work correctly even though a system error occurs. tolerate human errors prevents unauthorized access there could be some hardware problems such as hard disk crashs, ram becomes faulty etc. design systems in a way that human errors opportunity are minimized. test your system, froom unit to integration tests. setup monitoring tools, perfomance metrics and error rates. Scalability The system should handle the load gracefully if the volume (data, network etc) grows. what happens to system resources when you increase the load to your system how much resource you need to increase when you increase the load. response time is what client sees, request sent and response is received from the client latency is the duration that a request is waiting to be handled in response times it is better to use percentile, not the average. because it does not tell you how many users are affected by a specific number of delay. Maintainability Project should be easily developed by many other engineers who work on the project. cost of software are mostly based on the ongoing mainteiance, not the initial software development. projects should be evolvable: meaning making changes should be easy. simple: a project should not be complex, should be easy to work with. ","date":"2023-08-27","objectID":"/notes-on-designing-data-intensive-applications/:1:1","tags":["backend","database","books"],"title":"My Notes on Designing Data Intensive Applications","uri":"/notes-on-designing-data-intensive-applications/"},{"categories":null,"content":"CHAPTER 2 - Data Models and Query Languages ","date":"2023-08-27","objectID":"/notes-on-designing-data-intensive-applications/:2:0","tags":["backend","database","books"],"title":"My Notes on Designing Data Intensive Applications","uri":"/notes-on-designing-data-intensive-applications/"},{"categories":null,"content":"Relational Vs Document Model Most famous data format is SQL. Goal of relational model was to hide the implementation detail behind a cleaner interface rather than forcing developers to think the internal representation of the data. The driving forces for NoSQL (Document) Databases need for greater scalability specialized query operations not supported by SQL more dynamic and expressive data models. Chapter 2 will be continued. ","date":"2023-08-27","objectID":"/notes-on-designing-data-intensive-applications/:2:1","tags":["backend","database","books"],"title":"My Notes on Designing Data Intensive Applications","uri":"/notes-on-designing-data-intensive-applications/"},{"categories":null,"content":"CHAPTER 3 - STORAGE AND RETRIEVAL On the most basic model, a database needs to do 2 operations. it should store the given data when ask it again later, it should give the data back. The questions needs to be asked as an application developer probably would not be how the database handles storage and retrieval internally? But if you have to tune the program you use, it is better to know the internals of the tool. ","date":"2023-08-27","objectID":"/notes-on-designing-data-intensive-applications/:3:0","tags":["backend","database","books"],"title":"My Notes on Designing Data Intensive Applications","uri":"/notes-on-designing-data-intensive-applications/"},{"categories":null,"content":"WORLD SIMPLEST DATABASE Would be a key value store written into a file. db_set () { echo \"$1,$2\" \u003e\u003e database } db_get () { grep \"^$1,\" database | sed -e \"s/^$1,//\" | tail -n 1 } Similarly to what db_set function does, the databasess also uses a log internally, append-only data file. db_get function performance is terrible on large scale of data since it traverse the all of the file O(N). ","date":"2023-08-27","objectID":"/notes-on-designing-data-intensive-applications/:3:1","tags":["backend","database","books"],"title":"My Notes on Designing Data Intensive Applications","uri":"/notes-on-designing-data-intensive-applications/"},{"categories":null,"content":"Index To retrieve the data efficiently, you need an index. Index is an additional data which can be derived from the original set of data. Creating indexes may create an overhead to write operations, since it cannot be more efficient than writing to end of file. ","date":"2023-08-27","objectID":"/notes-on-designing-data-intensive-applications/:3:2","tags":["backend","database","books"],"title":"My Notes on Designing Data Intensive Applications","uri":"/notes-on-designing-data-intensive-applications/"},{"categories":null,"content":"HASH INDEXES ","date":"2023-08-27","objectID":"/notes-on-designing-data-intensive-applications/:3:3","tags":["backend","database","books"],"title":"My Notes on Designing Data Intensive Applications","uri":"/notes-on-designing-data-intensive-applications/"},{"categories":null,"content":"Motivation The motivation for me to write this blog post is that I want to have a consumer which uses goroutines for the messages received from SQS but almost all of the posts I read was did not exactly implemented as a worker pool integration. The posts uses new goroutines for each of the messages received and it might be useful for their case but if you process millions of records, creating and deleting millions of records might be a burden to garbage collector. So in this post, 10 goroutines will listen for all of the messages received. Note This case only will work if you need to process and delete the messages from the queue in each of the ReceiveMessage call. Otherwise, it might not be useful for your case. ","date":"2023-07-07","objectID":"/golang-sqs-consumer-worker-pool/:1:0","tags":null,"title":"Golang Sqs Consumer Worker Pool","uri":"/golang-sqs-consumer-worker-pool/"},{"categories":null,"content":"Design ","date":"2023-07-07","objectID":"/golang-sqs-consumer-worker-pool/:1:1","tags":null,"title":"Golang Sqs Consumer Worker Pool","uri":"/golang-sqs-consumer-worker-pool/"},{"categories":null,"content":"Implementation There are some things to consider. For our case the consumer should do following steps Receive message from the queue it can receive at most 10 messages in one single call to sqs. Send these 10 messages to the channel for workers to listen. Wait for these 10 messages process to finish. Release the workers so they can process again. It might be useful for your case, so please use with care with your judgement. ","date":"2023-07-07","objectID":"/golang-sqs-consumer-worker-pool/:2:0","tags":null,"title":"Golang Sqs Consumer Worker Pool","uri":"/golang-sqs-consumer-worker-pool/"},{"categories":null,"content":"CODE To understand the functions and methods used here, please have a visit to aws-sdk-go-v2/sqs import ( \"context\" \"sync\" \"github.com/aws/aws-sdk-go-v2/aws\" \"github.com/aws/aws-sdk-go-v2/service/sqs\" \"github.com/aws/aws-sdk-go-v2/service/sqs/types\" ) type Consumer struct { client sqs.Client queueName string } func (consumer *Consumer) Start(ctx context.Context) { params := \u0026sqs.ReceiveMessageInput{ AttributeNames: []types.QueueAttributeName{types.QueueAttributeNameAll}, MaxNumberOfMessages: 10, // max it can receive MessageAttributeNames: []string{string(types.QueueAttributeNameAll)}, QueueUrl: aws.String(consumer.queueName), WaitTimeSeconds: 20, // wait for 20 seconds at max for at least 1 message to be received } msgCh := make(chan types.Message) var wg sync.WaitGroup startPool(ctx, msgCh, \u0026wg) for { select { case \u003c-ctx.Done(): close(msgCh) return default: resp, err := consumer.client.ReceiveMessage(ctx, params) if err != nil { log.Msg(\"cannot receive messages\") continue } // add number of messages received from the queue wg.Add(len(resp.Messages)) // send received messages to sqs, so they can be processed for _, message := range resp.Messages { msgCh \u003c- message } // wait for workers in the pool to be finished. wg.Wait() } } } // startPool starts 10 goroutines which listens to the msgCh which receives the // messages from the SQS. func startPool(ctx context.Context, msgCh chan types.Message, wg *sync.WaitGroup) { for i := 0; i \u003c 10; i++ { go func() { for { select { case \u003c-ctx.Done(): return case msg, channelClosed := \u003c-msgCh: // If the channel is closed if !channelClosed { return } // handle the message here, insert your logic. // release the waitgroup to inform that the message has been processed. wg.Done() } } }() } } ","date":"2023-07-07","objectID":"/golang-sqs-consumer-worker-pool/:2:1","tags":null,"title":"Golang Sqs Consumer Worker Pool","uri":"/golang-sqs-consumer-worker-pool/"},{"categories":null,"content":"Some Points Let’s say you are receiving 1 million daily throughput from the SQS. For the 10 messages you received if you create 5 goroutines in each time in the end you will create 500_000 goroutines. if you create 5 goroutines which listens to a channel and process those messages, then you will only create 5 goroutines. Thanks for reading. Any feedback is appreciated. ","date":"2023-07-07","objectID":"/golang-sqs-consumer-worker-pool/:3:0","tags":null,"title":"Golang Sqs Consumer Worker Pool","uri":"/golang-sqs-consumer-worker-pool/"},{"categories":null,"content":"Introduction Go is an excellent programming language for building HTTP servers, thanks to its net/http package in the standard library, which makes it easy to attach HTTP handlers to any Go program. The standard library also includes packages that facilitate testing HTTP servers, making it just as effortless to test them as it is to build them. Nowadays, test coverage is widely accepted as an essential and valuable part of software development. Developers invest time in testing their code to get quick feedback when making changes, and a good test suite becomes an invaluable component of the software project when combined with continuous integration and delivery methodologies. Given the importance of a good test suite, what approach should developers using Go take when testing their HTTP servers? This article provides everything you need to know to test your Go HTTP servers thoroughly. ","date":"2023-03-05","objectID":"/testing-http-servers-in-go/:0:0","tags":["go","http","testing"],"title":"Testing HTTP Servers in Go","uri":"/testing-http-servers-in-go/"},{"categories":null,"content":"Http Server For Conversion of Roman Numerals We will have a web server which gives the roman numeral of the given number. We will only have 1 endpoint. Show the roman numeral of the number GET /roman ","date":"2023-03-05","objectID":"/testing-http-servers-in-go/:1:0","tags":["go","http","testing"],"title":"Testing HTTP Servers in Go","uri":"/testing-http-servers-in-go/"},{"categories":null,"content":"Example Request and Response Request curl --location --request GET 'http://localhost:8080/roman?query=1' Response { \"output\": \"I\" } ","date":"2023-03-05","objectID":"/testing-http-servers-in-go/:1:1","tags":["go","http","testing"],"title":"Testing HTTP Servers in Go","uri":"/testing-http-servers-in-go/"},{"categories":null,"content":"Code and Explanation package main import ( \"encoding/json\" \"log\" \"net/http\" \"strconv\" ) var ( nums = []int{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000} symbols = []string{\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"} ) func convertIntegerToRoman(input int) string { var ( i = len(nums) - 1 result string ) for input \u003e 0 { division := input / nums[i] input = input % nums[i] for division \u003e 0 { result += symbols[i] division = division - 1 } i = i - 1 } return result } type romanHandler struct{} func (h romanHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\", \"application/json\") if r.Method != http.MethodGet { http.Error(w, \"unsupported method\", http.StatusMethodNotAllowed) return } input := r.URL.Query().Get(\"query\") inputInt, err := strconv.Atoi(input) if err != nil { http.Error(w, \"invalid input\", http.StatusBadRequest) return } output := convertIntegerToRoman(inputInt) response := map[string]interface{}{ \"output\": output, } if err := json.NewEncoder(w).Encode(\u0026response); err != nil { return } } func main() { mux := http.NewServeMux() mux.Handle(\"/roman\", romanHandler{}) log.Fatal(http.ListenAndServe(\":8080\", mux)) } Points The function convertIntegerToRoman takes an integer and return the roman numeral conversion of the number. Please have a look on Convert Number Into Roman Numeral We accept a single query parameter named query in the URL which should have the number which will be converted. The struct implements the http.Handler interface by implementing the method of ServeHTTP(ResponseWriter, *Request) ","date":"2023-03-05","objectID":"/testing-http-servers-in-go/:1:2","tags":["go","http","testing"],"title":"Testing HTTP Servers in Go","uri":"/testing-http-servers-in-go/"},{"categories":null,"content":"Testing Of the Server The whole purpose of this blog was to learn how to test http servers in Go, so let’s find out. As we mentioned in the beginning Go has all of the tools we need to both create net/http and test net/http/httptest. All of the tools are included in the net module. Let’s create a file named main_test.go which has all of the tests for the HTTP Server. ","date":"2023-03-05","objectID":"/testing-http-servers-in-go/:2:0","tags":["go","http","testing"],"title":"Testing HTTP Servers in Go","uri":"/testing-http-servers-in-go/"},{"categories":null,"content":"Tests package main import ( \"fmt\" \"net/http\" \"net/http/httptest\" \"strings\" \"testing\" ) func TestRomanHandler(t *testing.T) { tt := []struct { name string httpMethod string query string responseBody string statusCode int }{ { name: \"unsupported httpMethod\", httpMethod: http.MethodPost, query: \"1\", responseBody: \"unsupported httpMethod\", statusCode: http.StatusMethodNotAllowed, }, { name: \"invalid input\", httpMethod: http.MethodGet, query: \"asd\", responseBody: `invalid input`, statusCode: http.StatusBadRequest, }, { name: \"correct query param\", httpMethod: http.MethodGet, query: \"1\", responseBody: `{\"output\":\"I\"}`, statusCode: http.StatusOK, }, } for _, tc := range tt { t.Run(tc.name, func(t *testing.T) { path := fmt.Sprintf(\"/roman?query=%s\", tc.query) request := httptest.NewRequest(tc.httpMethod, path, nil) responseRecorder := httptest.NewRecorder() romanHandler{}.ServeHTTP(responseRecorder, request) if responseRecorder.Code != tc.statusCode { t.Errorf(\"Want status '%d', got '%d'\", tc.statusCode, responseRecorder.Code) } if strings.TrimSpace(responseRecorder.Body.String()) != tc.responseBody { t.Errorf(\"Want '%s', got '%s'\", tc.responseBody, responseRecorder.Body) } }) } } To test the handler, we use the common table-driven approach and provide three cases: the http method is not correct http method is correct, but the query param is invalid both http method and query param is valid. For each case, we run a subtest that creates a new request and a response recorder. We use the httptest.NewRequest function to create an http.Request struct, which represents an incoming request to the handler. This allows us to simulate a real request without relying on an actual HTTP server. However, this function only handles the request half of the testing. To handle the response half, we use httptest.ResponseRecorder, which records the mutations of the http.ResponseWriter and enables us to make assertions on it later in the test. By using this duo of httptest.ResponseRecorder and http.Request, we can successfully test any HTTP handler in Go. Running the test will produce the following output. === RUN TestRomanHandler === RUN TestRomanHandler/unsupported_method === RUN TestRomanHandler/invalid_input === RUN TestRomanHandler/correct_query_param --- PASS: TestRomanHandler (0.00s) --- PASS: TestRomanHandler/unsupported_method (0.00s) --- PASS: TestRomanHandler/invalid_input (0.00s) --- PASS: TestRomanHandler/correct_query_param (0.00s) PASS ","date":"2023-03-05","objectID":"/testing-http-servers-in-go/:2:1","tags":["go","http","testing"],"title":"Testing HTTP Servers in Go","uri":"/testing-http-servers-in-go/"},{"categories":null,"content":"REFERENCES net/http Testing HTTP Servers By Ieftimov Converting Decimal To Roman ","date":"2023-03-05","objectID":"/testing-http-servers-in-go/:2:2","tags":["go","http","testing"],"title":"Testing HTTP Servers in Go","uri":"/testing-http-servers-in-go/"},{"categories":null,"content":"MongoDB \u0026 Golang Query Examples - Cheat Sheet This cheat sheet should help you about the MongoDB queries with Golang. We will start with some basic examples to more complex queries with Go Programming Language. The examples are written with Go 1.19 and go.mongodb.org/mongo-driver/mongo. ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:0:0","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"Table Of Contents Connecting to MongoDB Inserting A Document to MongoDB Writing Multiple Documents To MongoDB Finding Single Document From MongoDB Finding All Documents From MongoDB Updating Document(s) From MongoDB Deleting Document(s) From MongoDB ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:1:0","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"How to Connect to MongoDB with Golang Connecting to MongoDB is fairly simple, you just connect the uri generated by the MongoDB. Then we can use the client.Database() function to make sure that we are connecting to the correct database. package main import ( \"context\" \"log\" \"time\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() client, err := mongo.Connect(ctx, options.Client().ApplyURI(\"mongodb://localhost:27017\")) if err != nil { log.Fatal(err) } db := client.Database(\"testdb\") // disconnect the mongo client when main is completed defer func() { if err = client.Disconnect(ctx); err != nil { panic(err) } }() } To really make sure that we are connected to the correct database, we can use the Ping method. ctx, cancel = context.WithTimeout(context.Background(), 2*time.Second) defer cancel() err = client.Ping(ctx, readpref.Primary()) ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:2:0","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"Inserting A Document to MongoDB with Golang To insert a document to MongoDB, we can use the bson.D provided by the MongoDB. But to make the operations more simple and more realistic to real world applications, we will use structs with bson tags. The model we are using is type Car struct { Id primitive.ObjectID `bson:\"_id\"` Brand string `bson:\"brand\"` Model string `bson:\"model\"` Year int `bson:\"year\"` } Then we can simply use the InsertOne() method to insert a document to MongoDB. package main import ( \"context\" \"log\" \"time\" \"go.mongodb.org/mongo-driver/bson/primitive\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\" ) type Car struct { Id primitive.ObjectID `bson:\"_id\"` CreatedAt time.Time `bson:\"createdAt\"` Brand string `bson:\"brand\"` Model string `bson:\"model\"` Year int `bson:\"year\"` } func main() { ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() client, err := mongo.Connect(ctx, options.Client().ApplyURI(\"mongodb://localhost:27017\")) if err != nil { log.Fatal(err) } db := client.Database(\"testdb\") exampleData := Car{ Id: primitive.NewObjectID(), CreatedAt: time.Now().UTC(), Brand: \"Mercedes\", Model: \"G-360\", Year: 2002, } res, err := db.Collection(\"cars\").InsertOne(context.Background(), exampleData) if err != nil { log.Fatal(err) } // inserted id is ObjectID(\"639b62ae2518fbd9315e405d\") log.Printf(\"inserted id is %v\", res.InsertedID) } ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:3:0","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"Writing Multiple Documents To MongoDB with Golang We can use the InsertMany() method of the Collection object. However, the InsertMany() requires an []interface{} to work on. package main import ( \"context\" \"log\" \"time\" \"go.mongodb.org/mongo-driver/bson/primitive\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\" ) type Car struct { Id primitive.ObjectID `bson:\"_id\"` CreatedAt time.Time `bson:\"createdAt\"` Brand string `bson:\"brand\"` Model string `bson:\"model\"` Year int `bson:\"year\"` } func main() { ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() client, err := mongo.Connect(ctx, options.Client().ApplyURI(\"mongodb://localhost:27017\")) if err != nil { log.Fatal(err) } db := client.Database(\"testdb\") var data []interface{} data = append(data, Car{ Id: primitive.NewObjectID(), CreatedAt: time.Now().UTC(), Brand: \"Toyota\", Model: \"Corolla\", Year: 2008, }) data = append(data, Car{ Id: primitive.NewObjectID(), CreatedAt: time.Now().UTC(), Brand: \"Ford\", Model: \"Focus\", Year: 2021, }) res, err := db.Collection(\"cars\").InsertMany(context.Background(), data) if err != nil { log.Fatal(err) } // 2 documents inserted log.Printf(\"%v documents inserted\", len(res.InsertedIDs)) } ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:4:0","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"Finding Single Document From MongoDB with Golang To find a single document with a condition, we can use the FindOne() method of *Collection object. package main import ( \"context\" \"log\" \"time\" \"go.mongodb.org/mongo-driver/bson/primitive\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\" ) type Car struct { Id primitive.ObjectID `bson:\"_id\"` CreatedAt time.Time `bson:\"createdAt\"` Brand string `bson:\"brand\"` Model string `bson:\"model\"` Year int `bson:\"year\"` } func main() { ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() client, err := mongo.Connect(ctx, options.Client().ApplyURI(\"mongodb://localhost:27017\")) if err != nil { log.Fatal(err) } db := client.Database(\"testdb\") condition := bson.M{} cur, err := db.Collection(\"cars\").FindOne(context.Background(), condition) if err != nil { log.Fatal(err) } var data []Car if err := cur.All(context.Background(), \u0026data); err != nil { log.Fatal(err) } // now we can use the data array, which contains all of the documents for _, car := range data { log.Printf(\"the brand is %v\\n\", car.Brand) } } ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:5:0","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"Fetch the Lastly Created Document We can also pass mongo.Options to the Find() operation. Let’s say we want to fetch the lastly inserted document. we need to sort by the createdAt field it should be descending, that’s why we made the sort value as -1. var opts = options.FindOne().SetSort(bson.M{ \"createdAt\": -1, }) res := db.Collection(\"cars\").FindOne(context.Background(), bson.M{}, opts) if res.Err() != nil { log.Fatal(err) } ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:5:1","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"Finding All Documents From MongoDB with Golang To find the all documents in a collection, we can use the Find() method of *Collection object. In the below example, we did not specify any condition, which means that return all of the documents in the database. package main import ( \"context\" \"log\" \"time\" \"go.mongodb.org/mongo-driver/bson/primitive\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\" ) type Car struct { Id primitive.ObjectID `bson:\"_id\"` CreatedAt time.Time `bson:\"createdAt\"` Brand string `bson:\"brand\"` Model string `bson:\"model\"` Year int `bson:\"year\"` } func main() { ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() client, err := mongo.Connect(ctx, options.Client().ApplyURI(\"mongodb://localhost:27017\")) if err != nil { log.Fatal(err) } db := client.Database(\"testdb\") condition := bson.M{} cur, err := db.Collection(\"cars\").Find(context.Background(), condition) if err != nil { log.Fatal(err) } var data []Car if err := cur.All(context.Background(), \u0026data); err != nil { log.Fatal(err) } // now we can use the data array, which contains all of the documents for _, car := range data { log.Printf(\"the brand is %v\\n\", car.Brand) } } ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:6:0","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"Finding Many Documents With Condition If we would like to return the cars where the brand is Toyota, then we can change the condition variable as condition := bson.M{ \"brand\": \"Toyota\" } ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:6:1","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"Use Projection in Find Operations If you want to use projection in Find() operation, we can use the mongo.Options for that. Let’s say we would like to return 2 fields return the brand of the car. return a boolean field to check if the car is new if the production year of the car is 2022, it is new else, it is old. SetProjection() sets the value for the projection field. var opts = options.Find().SetProjection( bson.M{ \"brand\": 1, \"isNew\": bson.M{ \"$cond\": bson.M{ \"if\": bson.M{\"$gte\": bson.A{\"$year\", 2022}}, \"then\": true, \"else\": false}, }, }) cur, err := db.Collection(\"cars\").Find(context.Background(), bson.M{}, opts) More will come, so please stay tuned! ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:6:2","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"Update Single Document in MongoDB With Golang To update a single document, we should use the FindOneAndUpdate() or UpdateOne() operations. For this blog, we will use the FindOneAndUpdate() operation. package main import ( \"context\" \"log\" \"time\" \"go.mongodb.org/mongo-driver/bson\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() client, err := mongo.Connect(ctx, options.Client().ApplyURI(\"mongodb://localhost:27017\")) if err != nil { log.Fatal(err) } db := client.Database(\"testdb\") filter := bson.M{ \"brand\": \"Toyota\", \"model\": \"Corolla\", } update := bson.M{ \"year\": 2022, } res := db.Collection(\"cars\").FindOneAndUpdate(context.Background(), filter, update) if res.Err() != nil { log.Fatal(err) } // operation successful } How to return the updated document in MongoDB? We can use mongo.Options package to do that. We should set the return document option to after. opts := options.FindOneAndUpdate().SetReturnDocument(options.After) res := db.Collection(\"cars\").FindOneAndUpdate(context.Background(), filter, update, opts) // we can use the updated car document var updatedData Car if err := res.Decode(\u0026updatedData); err != nil { log.Fatal(err) } ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:6:3","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"Delete Document(s) from MongoDB with Golang To delete a document we can use DeleteOne() method of the *Collection object. To delete many documents, we can use the DeleteMany() method of the *Collection package main import ( \"context\" \"log\" \"time\" \"go.mongodb.org/mongo-driver/bson\" \"go.mongodb.org/mongo-driver/mongo\" \"go.mongodb.org/mongo-driver/mongo/options\" ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() client, err := mongo.Connect(ctx, options.Client().ApplyURI(\"mongodb://localhost:27017\")) if err != nil { log.Fatal(err) } db := client.Database(\"testdb\") filter := bson.M{ \"brand\": \"Toyota\", \"model\": \"Corolla\", } // for single document res, err := db.Collection(\"cars\").DeleteMany(context.Background(), filter) if err != nil { log.Fatal(err) } // 1 document is deleted. log.Printf(\"%v document is deleted\", res.DeletedCount) } More will come, so please stay tuned! ","date":"2022-12-15","objectID":"/golang-mongodb-query-examples/:6:4","tags":["golang","mongodb"],"title":"Golang \u0026 MongoDB Query Cheat Sheet","uri":"/golang-mongodb-query-examples/"},{"categories":null,"content":"Hello there, Welcome to My Blog. I graduated 🎓 from Western Kentucky University back in 2005 and currently working as a Software Engineer 💻 based in Kentucky. I enjoy reading quite a bit. One day I decided - why not start my own little blog to share some of my writings for others? I don’t consider myself the most prolific writer out there, but I plan to contribute small pieces here and there when inspiration strikes. Even if posts aren’t too frequent, I welcome anyone interested to subscribe or check back periodically for new content whenever I get around to penning something. Thanks for stopping by! Gary Here are my social links Github Linkedin Email ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]